function [t, p, t_inEntity, Name2id] = gwrap_loadmesh(varargin)
%gwrap_loadmesh loads a gmsh mesh.
%
% [t, p, t_inEntity, Name2id] = gwrap_loadmesh() loads the mesh assembled
% and generated by the basic gwrap workflow. The outputs are
%   t = 3xNe array containing the elements
%   p = 2xNp array of nodal coordinates
%   t_inEntity = 1xNe array containing the number of the surface each
%       element belongs to.
%   Name2id = a map containing the id number of each named surface. For
%       instance, elements in the surface named "slot" would be obtained by
%       t(:, t_inEntity == Name2id('stator')
% 
% Alternatively, gwrap_loadmesh(filepath) loads the specified msh file.
% 
% (c) 2017 Antti Lehikoinen / Aalto University

global gwrap_filename
if numel(varargin)
    filename = varargin{1};
else
    filename = gwrap_filename;
end

%skip unnecessary stuff in the beginning
global gwrap_PhysicalSurfaces
fid = fopen(strrep(filename, '.geo', '.msh'));
for k = 1:4
    fgetl(fid);
end

%scanning physical names
N_physicalNames = fscanf(fid, '%d', [1 1]);
if N_physicalNames ~= numel(gwrap_PhysicalSurfaces.keys)
    warning('Unexpected number of physical surfaces.');
end
Name2id = containers.Map();
for k = 1:N_physicalNames
    temp = fscanf(fid, '%d %d %s', [1 3]);
    Name = char(temp(4:(end-1)));
    id = temp(2);
    Name2id(Name) = id;
end

%skipping lines again
fgetl(fid);
fgetl(fid);
fgetl(fid);

%scanning nodes
Np = fscanf(fid, '%d', [1 1]);
temp = fscanf(fid, '%d %f %f %f', [4 Np])';
p = temp(:, 2:3)';

%skipping lines
fgetl(fid);
fgetl(fid);
fgetl(fid);

%scanning elements
Ne = fscanf(fid, '%d', [1 1]);  fgetl(fid);
t = zeros(3, Ne);
t_inEntity = zeros(1, Ne);
for ke = 1:Ne
    line = fgetl(fid);
    temp = strsplit(line);
    t_inEntity(ke) = str2double(temp{4});
    t(:,ke) = [str2double(temp{end-2}); str2double(temp{end-1}); str2double(temp{end})];
end
fclose(fid);

end